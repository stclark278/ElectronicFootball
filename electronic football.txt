%include "/usr/local/share/csc314/asm_io.inc"

; how frequently we check for input
; 1,000,000 - 1 second
%define TICK 50000      ; 20 hertz refresh rate
%define SNAP 1000000    ;wait 1 second after tackled

; the file that stores the initial state
%define BOARD_FILE 'board.txt'
%define END_SCREEN_FILE 'endscreen.txt'

; how to represent everything
%define WALL_CHAR '#'
%define PLAYER_CHAR 'O'
%define OPPONENT_CHAR 'X'
%define PLAYER_1_CHAR '1'
%define PLAYER_2_CHAR '2'

; the size of the game screen in characters
%define HEIGHT 16
%define WIDTH 89

; the player starting position.
; top left is considered (0,0)
; player 1
%define STARTX 67
%define STARTY 6
%define START_NT_X 49
%define START_NT_Y 6
%define START_TDE_X 49
%define START_TDE_Y 3
%define START_BDE_X 49
%define START_BDE_Y 9
%define START_LB_X 37
%define START_LB_Y 6
%define START_DB_X 19
%define START_DB_Y 6
%define XMIN 18

;player 2
%define STARTX_P2 19
%define STARTY_P2 6
%define START_NT_X_P2 37
%define START_NT_Y_P2 6
%define START_TDE_X_P2 37
%define START_TDE_Y_P2 3
%define START_BDE_X_P2 37
%define START_BDE_Y_P2 9
%define START_LB_X_P2 49
%define START_LB_Y_P2 6
%define START_DB_X_P2 67
%define START_DB_Y_P2 6
%define XMIN_P2 67


; these keys do things
%define EXITCHAR 'x'
%define UPCHAR 'w'
%define LEFTCHAR 'a'
%define DOWNCHAR 's'
%define RIGHTCHAR 'd'
%define KICKCHAR 'k'
%define GIVEUPCHAR  'g'

; colors
%define COLOR_YELLOW 27,"[33m"
%define COLOR_DEFAULT 27, "[0m"
%define COLOR_BLUE 27, "[34m"
%define COLOR_CYAN 27, "[36m"
%define COLOR_GREEN 27, "[32m"
%define COLOR_RED 27, "[31m"

segment .data

    ; used to fopen() the board file defined above
    board_file          db BOARD_FILE,0
    end_screen_file     db END_SCREEN_FILE,0

    ; used to change the terminal mode
    mode_r              db "r",0
    raw_mode_on_cmd     db "stty raw -echo",0
    raw_mode_off_cmd    db "stty -raw echo",0

    ; called by system() to clear/refresh the screen
    clear_screen_cmd    db "clear",0

    ; things the program will print
    help_str            db 13,10,COLOR_CYAN,"Controls: ", \
                            UPCHAR,"=UP / ", \
                            LEFTCHAR,"=LEFT / ", \
                            DOWNCHAR,"=DOWN / ", \
                            RIGHTCHAR,"=RIGHT",13,10, \
                            KICKCHAR,"=KICK (> 50 to go PUNT < 50 to go FIELDGOAL) / ", \
                            GIVEUPCHAR,"=GIVE UP / ", \
                            EXITCHAR,"=EXIT", \
                            COLOR_DEFAULT,13,10,10,0

    intro_fmt           db "Welcome to Electronic Football!!",10,"Made by Steven Clark",10,"CSC 314 Fall 2020",10,10,"Press ENTER to Continue",0

    num_players_fmt     db 13,"How many players (1 or 2)? ",0
    difficulty_fmt      db 13,"What difficulty (e = easy, h = hard)? ",0

    scoreboard_fmt      db "Timer     Player 1 Score     Player 2 Score     Down     To Go     Ball On     Player", \
                            13,10,COLOR_YELLOW,"%2d:%d%d           %2d                 %2d            %d        %2d          %2d         %d", \
                            COLOR_DEFAULT,13,10,10,0

    color_magenta       db  27, "[95m",0
    color_red           db  27, "[31m",0
    color_blue          db  27, "[34m",0
    color_yellow        db  27, "[33m",0
    color_green         db  27, "[32m",0
    color_default       db  27, "[0m",0

segment .bss

    ; this array stores the current rendered gameboard (HxW)
    board   resb    (HEIGHT * WIDTH)

    ; these variables store the current player position
    xpos    resd    1
    ypos    resd    1

    ; these variables store the current opponent positions
 
    NTx     resd    1
    NTy     resd    1
    TDEx    resd    1
    TDEy    resd    1
    BDEx    resd    1
    BDEy    resd    1
    LBx     resd    1
    LBy     resd    1
    DBx     resd    1
    DBy     resd    1
    xmin    resd    1

    ; scoreboard variables

    player          resd    1
    timer           resd    1
    minutes         resd    1
    sec_tens        resd    1
    sec_ones        resd    1
    player1_score   resd    1
    player2_score   resd    1
    ball_on         resd    1
    score_distance  resd    1
    first_down_distance     resd    1
    down            resd    1
    distance_ran    resd    1
    winner          resd    1
    num_players     resd    1
    difficulty      resd    1


segment .text

    global  asm_main
    global  raw_mode_on
    global  raw_mode_off
    global  init_board
    global  render

    extern  system
    extern  putchar
    extern  getchar
    extern  printf
    extern  fopen
    extern  fread
    extern  fgetc
    extern  fclose
    extern  usleep
    extern  fcntl

    extern  time
    extern  srand
    extern  rand

asm_main:
    enter   0,0
    pusha
    ;***************CODE STARTS HERE***************************

    ;srand ( time(NULL))
    push    0
    call    time
    add     esp, 4

    push    eax
    call    srand
    add     esp, 4

    ; intro screen and set number of players and difficulty

    push    clear_screen_cmd
    call    system
    add     esp, 4

    push    intro_fmt
    call    printf
    add     esp, 4
    call    getchar

    ask_num_players:
    push    clear_screen_cmd
    call    system
    add     esp, 4

    push    num_players_fmt
    call    printf
    add     esp, 4

    call    getchar
    cmp     eax, '1'
    jne     check_2_players
        mov     DWORD [num_players], 1
        jmp     ask_difficulty
    check_2_players:
    cmp     eax, '2'
    jne     ask_num_players
        mov     DWORD [num_players], 2

    ask_difficulty:
    push    clear_screen_cmd
    call    system
    add     esp, 4

    push    difficulty_fmt
    call    printf
    add     esp, 4

    call    getchar
    cmp     eax, 'e'
    jne     check_hard_difficulty
        mov     DWORD [difficulty], 1
        jmp     start_game
    check_hard_difficulty:
    cmp     eax, 'h'
    jne     ask_difficulty
        mov     DWORD [difficulty], 2

    start_game:
    ; put the terminal in raw mode so the game works nicely
    call    raw_mode_on

    ; read the game board file into the global variable
    call    init_board

    coin_flip:
    call    rand
    cdq
    mov     ebx, 2
    idiv    ebx
    cmp     edx, 1
    je      coin_flip_cont
        mov     DWORD [player], 1
        jmp     coin_flip_end
    coin_flip_cont:
    mov     DWORD [player], 2
    coin_flip_end:

    ; set scoreboard to starting values
    mov     DWORD [timer], 13200
    mov     DWORD [minutes], 10
    mov     DWORD [sec_tens], 0
    mov     DWORD [sec_ones], 0
    mov     DWORD [player1_score], 0
    mov     DWORD [player2_score], 0
    mov     DWORD [score_distance], 80
    mov     DWORD [down], 1
    mov     DWORD [first_down_distance], 10
    mov     DWORD [ball_on], 20

    restart_game_loop:

    dec     DWORD [timer]
    cmp     DWORD [timer], 1200
    jle     game_loop_timer_zero


    ; set the player at the proper start position
    cmp     DWORD [player], 2
    je      player2_setup

    mov     DWORD [xpos], STARTX
    mov     DWORD [ypos], STARTY
    mov     DWORD [NTx], START_NT_X
    mov     DWORD [NTy], START_NT_Y
    mov     DWORD [TDEx], START_TDE_X
    mov     DWORD [TDEy], START_TDE_Y
    mov     DWORD [BDEx], START_BDE_X
    mov     DWORD [BDEy], START_BDE_Y
    mov     DWORD [LBx], START_LB_X
    mov     DWORD [LBy], START_LB_Y
    mov     DWORD [DBx], START_DB_X
    mov     DWORD [DBy], START_DB_Y
    mov     DWORD [xmin], XMIN
    jmp     positions_set

    player2_setup:

    mov     DWORD [xpos], STARTX_P2
    mov     DWORD [ypos], STARTY_P2
    mov     DWORD [NTx], START_NT_X_P2
    mov     DWORD [NTy], START_NT_Y_P2
    mov     DWORD [TDEx], START_TDE_X_P2
    mov     DWORD [TDEy], START_TDE_Y_P2
    mov     DWORD [BDEx], START_BDE_X_P2
    mov     DWORD [BDEy], START_BDE_Y_P2
    mov     DWORD [LBx], START_LB_X_P2
    mov     DWORD [LBy], START_LB_Y_P2
    mov     DWORD [DBx], START_DB_X_P2
    mov     DWORD [DBy], START_DB_Y_P2
    mov     DWORD [xmin], XMIN_P2
 
    positions_set:
    ;waits for user input to hike the ball and start loop
        ; draw the game board
        call    render
 
        push    SNAP
        call    usleep
        add     esp, 4

        ; get an action from the user
        pre_snap_loop:
        call    nonblocking_getchar
        cmp     eax, -1
        je      pre_snap_loop_end
            jmp     pre_snap_loop
        pre_snap_loop_end:
        call    render
        call    getchar
        mov     edx, eax
        mov     DWORD [distance_ran], -2
        jmp     hike

    ; the game happens in this loop
    ; the steps are...
    ;   1. render (draw) the current board
    ;   2. get a character from the user
    ;   3. store current xpos,ypos in esi,edi
    ;   4. update xpos,ypos based on character from user
    ;   5. check what's in the buffer (board) at new xpos,ypos
    ;   6. if it's a wall, reset xpos,ypos to saved esi,edi
    ;   7. otherwise, just continue! (xpos,ypos are ok)
    game_loop:

        dec     DWORD [timer]
        cmp     DWORD [timer], 1200
        jle     clock_at_zeros
        mov     eax, DWORD [timer]
        sub     eax, 1200
        cdq
        mov     ecx, 20
        div     ecx
        cdq
        mov     ecx, 60
        div     ecx
        mov     DWORD [minutes], eax
        mov     eax, edx
        cdq
        mov     ecx, 10
        div     ecx
        mov     DWORD [sec_tens], eax
        mov     DWORD [sec_ones], edx
        jmp     refresh_rate
        clock_at_zeros:
        mov     DWORD [minutes], 0
        mov     DWORD [sec_tens], 0
        mov     DWORD [sec_ones], 0

        ; slow down refresh rate to set rate up top
        refresh_rate:
        push    TICK
        call    usleep
        add     esp, 4

        mov     eax, DWORD [difficulty]
        cmp     eax, 1
        jne     hard_mode
            mov     ebx, 40
            jmp     run_timer
        hard_mode:
            mov     ebx, 20
        run_timer:
        mov     eax, DWORD [timer]
        cdq
        idiv    ebx
        cmp     edx, 0
        jne     skip_move
            cmp     DWORD [player], 2
            je      oppo_2_move
            call    opponent_1_move
            jmp     skip_move
            oppo_2_move:
            call    opponent_2_move

        skip_move:

        ; draw the game board
        call    render

        ; continue to refresh until tackled
        call    nonblocking_getchar


        ; al = -1
        ; al = char
        cmp     al, -1
        je      check_tackle

        hike:

        ; store the current position
        ; we will test if the new position is legal
        ; if not, we will restore these
        mov     esi, [xpos]
        mov     edi, [ypos]

        ; choose what to do

        cmp     eax, EXITCHAR
        je      game_loop_end
        cmp     eax, UPCHAR
        je      move_up
        cmp     eax, LEFTCHAR
        je      move_left
        cmp     eax, DOWNCHAR
        je      move_down
        cmp     eax, RIGHTCHAR
        je      move_right
        cmp     eax, KICKCHAR
        je      kick
        cmp     eax, GIVEUPCHAR
        je      game_loop_timer_zero
        jmp     input_end           ; or just do nothing

        ; move the player according to the input character
        move_up:
            dec     DWORD [ypos]
            dec     DWORD [ypos]
            dec     DWORD [ypos]
            jmp     input_end
        move_left:
            dec     DWORD [xpos]
            dec     DWORD [xpos]
            dec     DWORD [xpos]
            dec     DWORD [xpos]
            dec     DWORD [xpos]
            dec     DWORD [xpos]
            cmp     DWORD [player], 2
            je      player2_distance_decrease
                inc     DWORD [distance_ran]
                jmp     input_end
            player2_distance_decrease:
            dec     DWORD [distance_ran]
            jmp     input_end
        move_down:
            inc     DWORD [ypos]
            inc     DWORD [ypos]
            inc     DWORD [ypos]
            jmp     input_end
        move_right:
            inc     DWORD [xpos]
            inc     DWORD [xpos]
            inc     DWORD [xpos]
            inc     DWORD [xpos]
            inc     DWORD [xpos]
            inc     DWORD [xpos]
            cmp     DWORD [player], 2
            je      player2_distance_increase
                dec     DWORD [distance_ran]
                jmp     input_end
            player2_distance_increase:
            inc     DWORD [distance_ran]
            jmp     input_end
        input_end:

     ; wrap around after reaching endzone
        cmp     DWORD [player], 2
        je      player_2_wrap_check
 
        mov     eax, DWORD [xpos]
        mov     ecx, DWORD [xmin]
        cmp     eax, ecx
        jge     check_wall
            mov     DWORD [xpos], STARTX
            jmp     valid_move
 
        player_2_wrap_check:
        mov     eax, DWORD [xpos]
        mov     ecx, DWORD [xmin]
        cmp     eax, ecx
        jle     check_wall
            mov     DWORD [xpos], STARTX_P2
            jmp     valid_move

        ; (W * y) + x = pos

        ; compare the current position to the wall character
        check_wall:
        mov     eax, WIDTH
        mul     DWORD [ypos]
        add     eax, [xpos]
        lea     eax, [board + eax]
        cmp     BYTE [eax], WALL_CHAR
        jne     valid_move

            ; opps, that was an invalid move, reset
            invalid_move:
            mov     DWORD [xpos], esi
            mov     DWORD [ypos], edi

        valid_move:

        ; determine if player is tackled
        check_tackle:
        mov     eax, DWORD [xpos]
        mov     ebx, DWORD [ypos]

        ; check Nose Tackle
        mov     ecx, DWORD [NTx]
        mov     edx, DWORD [NTy]
        cmp     eax, ecx
        jne     check_tackle_TDE
        cmp     ebx, edx
        jne     check_tackle_TDE
        jmp     player_tackled

        ; check Top Defensive End
        check_tackle_TDE:
        mov     ecx, DWORD [TDEx]
        mov     edx, DWORD [TDEy]
        cmp     eax, ecx
        jne     check_tackle_BDE
        cmp     ebx, edx
        jne     check_tackle_BDE
        jmp     player_tackled

        ; check Bottom Defensive End
        check_tackle_BDE:
        mov     ecx, DWORD [BDEx]
        mov     edx, DWORD [BDEy]
        cmp     eax, ecx
        jne     check_tackle_LB
        cmp     ebx, edx
        jne     check_tackle_LB
        jmp     player_tackled

        ; check Line Backer
        check_tackle_LB:
        mov     ecx, DWORD [LBx]
        mov     edx, DWORD [LBy]
        cmp     eax, ecx
        jne     check_tackle_DB
        cmp     ebx, edx
        jne     check_tackle_DB
        jmp     player_tackled

        ; check Defensive Back
        check_tackle_DB:
        mov     ecx, DWORD [DBx]
        mov     edx, DWORD [DBy]
        cmp     eax, ecx
        jne     keep_running
        cmp     ebx, edx
        jne     keep_running
        jmp     player_tackled

    keep_running:
    mov     eax, DWORD [distance_ran]
    cmp     DWORD [score_distance], eax
    jle     player_scored_TD
    jmp     game_loop

    player_tackled:
    mov     eax, DWORD [distance_ran]
    sub     DWORD [score_distance], eax
    cmp     DWORD [first_down_distance], eax
    jle     first_down
        inc     DWORD [down]
        cmp     DWORD [down], 5
        jl      keep_possession
            jmp     change_possession

        keep_possession:
        sub     DWORD [first_down_distance], eax
        jmp     ball_is_on

    first_down:
    mov     DWORD [down], 1
    cmp     DWORD [score_distance], 10
    jge     first_and_10
        mov     eax, DWORD [score_distance]
        mov     DWORD [first_down_distance], eax
        jmp     ball_is_on
    first_and_10:
    mov     DWORD [first_down_distance], 10
    jmp     ball_is_on

    ball_is_on:
    cmp     DWORD [score_distance], 50
    jle     less_than_fifty
        mov     eax, DWORD [score_distance]
        sub     eax, 50
        mov     ebx, 50
        sub     ebx, eax
        mov     DWORD [ball_on], ebx
        jmp     restart_game_loop

        less_than_fifty:
        mov     eax, DWORD [score_distance]
        mov     DWORD[ball_on], eax
        jmp     restart_game_loop

    kick:
    cmp     DWORD [score_distance], 50
    jle     player_scored_FG
       jmp     change_possession

    player_scored_FG:
    cmp     DWORD [player], 1
    jne     player_2_FG
        add     DWORD [player1_score], 3
        jmp     change_possession
    player_2_FG:
    add     DWORD [player2_score], 3
    jmp     change_possession

    player_scored_TD:
    cmp     DWORD [player], 1
    jne     player_2_TD
        add     DWORD [player1_score], 7
        jmp     change_possession
    player_2_TD:
    add     DWORD [player2_score], 7
    jmp     change_possession

    change_possession:
    cmp     DWORD [player], 1
    je      player2_possession
        mov     DWORD [player], 2
        jmp     player1_possession

    player1_possession:
    mov     DWORD [player], 1
    mov     DWORD [score_distance], 80
    mov     DWORD [down], 1
    mov     DWORD [first_down_distance], 10
    mov     DWORD [ball_on], 20
    jmp     restart_game_loop

    player2_possession:
    cmp     DWORD [num_players], 1
    jne     cont_player2_possession
        jmp     computer_possession
    cont_player2_possession:
    mov     DWORD [player], 2
    mov     DWORD [score_distance], 80
    mov     DWORD [down], 1
    mov     DWORD [first_down_distance], 10
    mov     DWORD [ball_on], 20
    jmp     restart_game_loop

    computer_possession:
    mov     DWORD [player], 2
    call    rand
    cdq
    mov     ebx, 10
    idiv    ebx

    cmp     edx, 2
    jle     player_2_TD
    cmp     edx, 7
    jle     player_2_FG
    jmp     player1_possession

    game_loop_timer_zero:
    mov     eax, DWORD [player1_score]
    cmp     DWORD [player2_score], eax
    je      tie
    cmp     DWORD [player2_score], eax
    jl      player_1_wins
        mov     DWORD [winner], 2
        jmp     end_game

    player_1_wins:
    mov     DWORD [winner], 1
    jmp     end_game

    tie:
    mov     DWORD [winner], ' '
    jmp     end_game

    end_game:
    mov     DWORD [timer], 0
    call    end_screen
    call    render

    game_loop_end:

    ; restore old terminal functionality
    call raw_mode_off

    ;***************CODE ENDS HERE*****************************
    popa
    mov     eax, 0
    leave
    ret

 ; === FUNCTION ===
 raw_mode_on:

    push    ebp
    mov     ebp, esp

    push    raw_mode_on_cmd
    call    system
    add     esp, 4

    mov     esp, ebp
    pop     ebp
    ret

; === FUNCTION ===
raw_mode_off:

    push    ebp
    mov     ebp, esp

    push    raw_mode_off_cmd
    call    system
    add     esp, 4

    mov     esp, ebp
    pop     ebp
    ret

; === FUNCTION ===
init_board:

    push    ebp
    mov     ebp, esp

    ; FILE* and loop counter
    ; ebp-4, ebp-8
    sub     esp, 8

    ; open the file
    push    mode_r
    push    board_file
    call    fopen
    add     esp, 8
    mov     DWORD [ebp-4], eax

    ; read the file data into the global buffer
    ; line-by-line so we can ignore the newline characters
    mov     DWORD [ebp-8], 0
    read_loop:
    cmp     DWORD [ebp-8], HEIGHT
    je      read_loop_end

        ; find the offset (WIDTH * counter)
        mov     eax, WIDTH
        mul     DWORD [ebp-8]
        lea     ebx, [board + eax]

        ; read the bytes into the buffer
        push    DWORD [ebp-4]
        push    WIDTH
        push    1
        push    ebx
        call    fread
        add     esp, 16

        ; slurp up the newline
        push    DWORD [ebp-4]
        call    fgetc
        add     esp, 4

    inc     DWORD [ebp-8]
    jmp     read_loop
    read_loop_end:

    ; close the open file handle
    push    DWORD [ebp-4]
    call    fclose
    add     esp, 4

    mov     esp, ebp
    pop     ebp
    ret

; === FUNCTION ===
end_screen:

    push    ebp
    mov     ebp, esp

    ; FILE* and loop counter
    ; ebp-4, ebp-8
    sub     esp, 8

    ; open the file
    push    mode_r
    push    end_screen_file
    call    fopen
    add     esp, 8
    mov     DWORD [ebp-4], eax

    ; read the file data into the global buffer
    ; line-by-line so we can ignore the newline characters
    mov     DWORD [ebp-8], 0
    read_loop_end_screen:
    cmp     DWORD [ebp-8], HEIGHT
    je      read_loop_end_screen_end

        ; find the offset (WIDTH * counter)
        mov     eax, WIDTH
        mul     DWORD [ebp-8]
        lea     ebx, [board + eax]

        ; read the bytes into the buffer
        push    DWORD [ebp-4]
        push    WIDTH
        push    1
        push    ebx
        call    fread
        add     esp, 16

        ; slurp up the newline
        push    DWORD [ebp-4]
        call    fgetc
        add     esp, 4

    inc     DWORD [ebp-8]
    jmp     read_loop_end_screen
    read_loop_end_screen_end:

    ; close the open file handle
    push    DWORD [ebp-4]
    call    fclose
    add     esp, 4

    mov     esp, ebp
    pop     ebp
    ret

; === FUNCTION ===
render:

    push    ebp
    mov     ebp, esp

    ; two ints, for two loop counters
    ; ebp-4, ebp-8
    sub     esp, 8

    ; clear the screen
    push    clear_screen_cmd
    call    system
    add     esp, 4

    ; print the help information
    push    help_str
    call    printf
    add     esp, 4

    push    DWORD [player]
    push    DWORD [ball_on]
    push    DWORD [first_down_distance]
    push    DWORD [down]
    push    DWORD [player2_score]
    push    DWORD [player1_score]
    push    DWORD [sec_ones]
    push    DWORD [sec_tens]
    push    DWORD [minutes]
    push    scoreboard_fmt
    call    printf
    add     esp, 8

    ; outside loop by height
    ; i.e. for(c=0; c<height; c++)
    mov     DWORD [ebp-4], 0
    y_loop_start:
    cmp     DWORD [ebp-4], HEIGHT
    je      y_loop_end

        ; inside loop by width
        ; i.e. for(c=0; c<width; c++)
        mov     DWORD [ebp-8], 0
        x_loop_start:
        cmp     DWORD [ebp-8], WIDTH
        je      x_loop_end

        cmp     DWORD [timer], 0
        jne     check_players
            cmp     DWORD [ebp-4], 8
            jne     print_board
            cmp     DWORD [ebp-8], 48
            jne     print_board
                jmp     print_winner
 
            ; check for player (xpos,ypos)=(x,y)
            check_players:
            mov     eax, [xpos]
            mov     ecx, DWORD [ebp-8]
            cmp     eax, ecx
            je      check_ypos
            dec     ecx
            cmp     eax, ecx
            je      check_ypos
            dec     ecx
            cmp     eax, ecx
            je      check_ypos
            jmp     check_NTx

            check_ypos:
            mov     eax, [ypos]
            mov     ecx, DWORD [ebp-4]
            cmp     eax, ecx
            je      print_player
            dec     ecx
            cmp     eax, ecx
            je      print_player
            jmp     check_NTx

            ; check for Nose Tackle (xpos,ypos)=(x,y)
            check_NTx:
            mov     eax, [NTx]
            mov     ecx, DWORD [ebp-8]
            cmp     eax, ecx
            je      check_NTy
            dec     ecx
            cmp     eax, ecx
            je      check_NTy
            dec     ecx
            cmp     eax, ecx
            je      check_NTy
            jmp     check_TDEx

            check_NTy:
            mov     eax, [NTy]
            mov     ecx, DWORD [ebp-4]
            cmp     eax, ecx
            je      print_opponent
            dec     ecx
            cmp     eax, ecx
            je      print_opponent
            jmp     check_TDEx

            ; check for Top Defensive End (xpos,ypos)=(x,y)
            check_TDEx:
            mov     eax, [TDEx]
            mov     ecx, DWORD [ebp-8]
            cmp     eax, ecx
            je      check_TDEy
            dec     ecx
            cmp     eax, ecx
            je      check_TDEy
            dec     ecx
            cmp     eax, ecx
            je      check_TDEy
            jmp     check_BDEx

            check_TDEy:
            mov     eax, [TDEy]
            mov     ecx, DWORD [ebp-4]
            cmp     eax, ecx
            je      print_opponent
            dec     ecx
            cmp     eax, ecx
            je      print_opponent
            jmp     check_BDEx

            ; check for Top Defensive End (xpos,ypos)=(x,y)
            check_BDEx:
            mov     eax, [BDEx]
            mov     ecx, DWORD [ebp-8]
            cmp     eax, ecx
            je      check_BDEy
            dec     ecx
            cmp     eax, ecx
            je      check_BDEy
            dec     ecx
            cmp     eax, ecx
            je      check_BDEy
            jmp     check_LBx

            check_BDEy:
            mov     eax, [BDEy]
            mov     ecx, DWORD [ebp-4]
            cmp     eax, ecx
            je      print_opponent
            dec     ecx
            cmp     eax, ecx
            je      print_opponent
            jmp     check_LBx

            ; check for Top Defensive End (xpos,ypos)=(x,y)
            check_LBx:
            mov     eax, [LBx]
            mov     ecx, DWORD [ebp-8]
            cmp     eax, ecx
            je      check_LBy
            dec     ecx
            cmp     eax, ecx
            je      check_LBy
            dec     ecx
            cmp     eax, ecx
            je      check_LBy
            jmp     check_DBx

            check_LBy:
            mov     eax, [LBy]
            mov     ecx, DWORD [ebp-4]
            cmp     eax, ecx
            je      print_opponent
            dec     ecx
            cmp     eax, ecx
            je      print_opponent
            jmp     check_DBx

            ; check for Bottom Defensive End (xpos,ypos)=(x,y)
            check_DBx:
            mov     eax, [DBx]
            mov     ecx, DWORD [ebp-8]
            cmp     eax, ecx
            je      check_DBy
            dec     ecx
            cmp     eax, ecx
            je      check_DBy
            dec     ecx
            cmp     eax, ecx
            je      check_DBy
            jmp     print_board

            check_DBy:
            mov     eax, [DBy]
            mov     ecx, DWORD [ebp-4]
            cmp     eax, ecx
            je      print_opponent
            dec     ecx
            cmp     eax, ecx
            je      print_opponent
            jmp     print_board

                ; if both were equal, print the player
            print_player:
                push    PLAYER_CHAR
                push    color_magenta
                call    printf
                add     esp, 4
                jmp     print_end
            print_opponent:
                push    OPPONENT_CHAR
                push    color_red
                call    printf
                add     esp, 4
                jmp     print_end
            print_winner:
                cmp     DWORD [winner], 1
                jne     print_player_2
                    push    PLAYER_1_CHAR
                    jmp     print_end
            print_player_2:
                cmp     DWORD [winner], 2
                jne     print_board
                    push    PLAYER_2_CHAR
                    jmp     print_end
            print_board:
                ; otherwise print whatever's in the buffer
                mov     eax, [ebp-4]
                mov     ebx, WIDTH
                mul     ebx
                add     eax, [ebp-8]
                mov     ebx, 0
                mov     bl, BYTE [board + eax]

                cmp     bl, '#'
                jne     not_pound
                    push    color_green
                    call    printf
                    add     esp, 4
                not_pound:
                cmp     bl, '@'
                jne     not_at
                    push    color_blue
                    call    printf
                    add     esp, 4
                not_at:
                cmp     bl, '_'
                jne     not_underscore
                    push    color_yellow
                    call    printf
                    add     esp, 4
                not_underscore:
                cmp     bl, '|'
                jne     not_bar
                    push    color_yellow
                    call    printf
                    add     esp, 4
                not_bar:

                push    ebx
            print_end:
            call    putchar
            add     esp, 4
            push    color_default
            call    printf
            add     esp, 4

        inc     DWORD [ebp-8]
        jmp     x_loop_start
        x_loop_end:

        ; write a carriage return (necessary when in raw mode)
        push    0x0d
        call    putchar
        add     esp, 4

        ; write a newline
        push    0x0a
        call    putchar
        add     esp, 4

    inc     DWORD [ebp-4]
    jmp     y_loop_start
    y_loop_end:

    mov     esp, ebp
    pop     ebp
    ret

; === FUNCTION ===
nonblocking_getchar:

; returns -1 on no-data
; returns char on succes

; magic values
%define F_GETFL 3
%define F_SETFL 4
%define O_NONBLOCK 2048
%define STDIN 0

        push    ebp
        mov     ebp, esp

        ; single int used to hold flags
        ; single character (aligned to 4 bytes) return
        sub     esp, 8

        ; get current stdin flags
        ; flags = fcntl(stdin, F_GETFL, 0)
        push    0
        push    F_GETFL
        push    STDIN
        call    fcntl
        add     esp, 12
        mov     DWORD [ebp-4], eax

        ; set non-blocking mode on stdin
        ; fcntl(stdin, F_SETFL, flags | O_NONBLOCK)
        or      DWORD [ebp-4], O_NONBLOCK
        push    DWORD [ebp-4]
        push    F_SETFL
        push    STDIN
        call    fcntl
        add     esp, 12

        call    getchar
        mov     DWORD [ebp-8], eax

        ; restore blocking mode
        ; fcntl(stdin, F_SETFL, flags ^ O_NONBLOCK
        xor     DWORD [ebp-4], O_NONBLOCK
        push    DWORD [ebp-4]
        push    F_SETFL
        push    STDIN
        call    fcntl
        add     esp, 12

        mov     eax, DWORD [ebp-8]

        mov     esp, ebp
        pop     ebp
        ret

; === FUNCTION +++
opponent_1_move:

; moves opponent with random numbers
; only moves certain opponants depending on where the player is
    push    ebp
    mov     ebp, esp


    cmp     DWORD [xpos], 55
    jge     move_line
    jmp     move_backers

    move_line:
    call    rand
    cdq
    mov     ebx, 6
    idiv    ebx

    cmp     edx, 0
    je      move_TDE
    cmp     edx, 5
    je      move_BDE
    jmp     move_NT

    move_backers:
    call    rand
    cdq
    mov     ebx, 10
    idiv    ebx
    cmp     edx, 5
    jge     end_move

    cmp     DWORD [xpos], 37
    jl      move_DB
    jmp     move_LB

    move_NT:
    mov     eax, DWORD [ypos]
    cmp     DWORD [NTy], eax
    jl      move_NT_down
    cmp     DWORD [NTy], eax
    jg      move_NT_up
    cmp     DWORD [NTy], eax
    je      move_NT_forward

        move_NT_down:
            mov     eax, DWORD [BDEx]
            cmp     DWORD [NTx], eax
            je      move_NT_forward
                add     DWORD [NTy], 3
                jmp     end_move

        move_NT_up:
            mov     eax, DWORD [TDEx]
            cmp     DWORD [NTx], eax
            je      move_NT_forward
                sub     DWORD [NTy], 3
                jmp     end_move

        move_NT_forward:
            mov     eax, DWORD [BDEy]
            cmp     DWORD [NTy], eax
            je      end_move
            mov     eax, DWORD [TDEy]
            cmp     DWORD [NTy], eax
            je      end_move
            cmp     DWORD [BDEx], 67
            je      end_move
                add     DWORD [NTx], 6
                jmp     end_move

    move_TDE:
    mov     eax, DWORD [NTy]
    cmp     DWORD [TDEy], eax
    jge     move_TDE_up
    cmp     DWORD [TDEy], eax
    jl      move_TDE_down

        move_TDE_up:
            cmp     DWORD [TDEy], 3
            je      move_TDE_down
                sub     DWORD [TDEy], 3
                jmp     end_move

        move_TDE_down:
            cmp     DWORD [TDEy], 6
            je      move_TDE_forward
            mov     edi, DWORD [BDEy]
            sub     edi, 3
            cmp     DWORD [TDEy], edi
            je      move_TDE_forward
            mov     eax, DWORD [NTx]
            cmp     DWORD [TDEx], eax
            je      move_TDE_forward
                add     DWORD [TDEy], 3
                jmp     end_move

        move_TDE_forward:
            mov     eax, DWORD [NTy]
            cmp     DWORD [TDEy], eax
            je      end_move
            cmp     DWORD [BDEx], 67
            je      end_move
                add     DWORD [BDEx], 6
                jmp     end_move

    move_BDE:
    mov     eax, DWORD [NTy]
    cmp     DWORD [BDEy], eax
    jge     move_BDE_down
    cmp     DWORD [BDEy], eax
    jl      move_BDE_up

        move_BDE_down:
            cmp     DWORD [BDEy], 9
            je      move_BDE_forward
                add     DWORD [BDEy], 3
                jmp     end_move

        move_BDE_up:
            cmp     DWORD [BDEy], 6
            je      move_BDE_forward
            mov     edi, DWORD [TDEy]
            add     edi, 3
            cmp     DWORD [BDEy], edi
            je      move_BDE_forward
            mov     eax, DWORD [NTx]
            cmp     DWORD [BDEx], eax
            je      move_BDE_forward
                sub     DWORD [BDEy], 3
                jmp     end_move

        move_BDE_forward:
            mov     eax, DWORD [NTy]
            cmp     DWORD [BDEy], eax
            je      end_move
            cmp     DWORD [BDEx], 67
            je      end_move
                add     DWORD [BDEx], 6
                jmp     end_move

    move_LB:
    mov     eax, DWORD [ypos]
    cmp     DWORD [LBy], eax
    jg      move_LB_up
    cmp     DWORD [LBy], eax
    jl      move_LB_down
    jmp     end_move

        move_LB_up:
            sub     DWORD [LBy], 3
            jmp     end_move

        move_LB_down:
            add     DWORD [LBy], 3
            jmp     end_move

    move_DB:
    mov     eax, DWORD [ypos]
    cmp     DWORD [DBy], eax
    jg      move_DB_up
    cmp     DWORD [DBy], eax
    jl      move_DB_down
    jmp     end_move

        move_DB_up:
            sub     DWORD [DBy], 3
            jmp     end_move

        move_DB_down:
            add     DWORD [DBy], 3
            jmp     end_move

    end_move:
    mov     esp, ebp
    pop     ebp
    ret

; === FUNCTION +++
opponent_2_move:

; moves opponent with random numbers
; only moves certain opponants depending on where the player is
   push    ebp
   mov     ebp, esp


    cmp     DWORD [xpos], 31
    jle     move_line2
    jmp     move_backers2

    move_line2:
    call    rand
    cdq
    mov     ebx, 6
    idiv    ebx

    cmp     edx, 0
    je      move_TDE2
    cmp     edx, 5
    je      move_BDE2
    jmp     move_NT2

    move_backers2:
    call    rand
    cdq
    mov     ebx, 10
    idiv    ebx
    cmp     edx, 5
    jge     end_move

    cmp     DWORD [xpos], 55
    jge     move_DB2
    jmp     move_LB2

    move_NT2:
    mov     eax, DWORD [ypos]
    cmp     DWORD [NTy], eax
    jl      move_NT_down2
    cmp     DWORD [NTy], eax
    jg      move_NT_up2
    cmp     DWORD [NTy], eax
    je      move_NT_forward2

        move_NT_down2:
            mov     eax, DWORD [BDEx]
            cmp     DWORD [NTx], eax
            je      move_NT_forward2
                add     DWORD [NTy], 3
                jmp     end_move2

        move_NT_up2:
            mov     eax, DWORD [TDEx]
            cmp     DWORD [NTx], eax
            je      move_NT_forward2
                sub     DWORD [NTy], 3
                jmp     end_move2

        move_NT_forward2:
            mov     eax, DWORD [BDEy]
            cmp     DWORD [NTy], eax
            je      end_move2
            mov     eax, DWORD [TDEy]
            cmp     DWORD [NTy], eax
            je      end_move2
            cmp     DWORD [BDEx], 67
            je      end_move2
                sub     DWORD [NTx], 6
                jmp     end_move2

    move_TDE2:
    mov     eax, DWORD [NTy]
    cmp     DWORD [TDEy], eax
    jge     move_TDE_up2
    cmp     DWORD [TDEy], eax
    jl      move_TDE_down2

        move_TDE_up2:
            cmp     DWORD [TDEy], 3
            je      move_TDE_down2
                sub     DWORD [TDEy], 3
                jmp     end_move2

        move_TDE_down2:
            cmp     DWORD [TDEy], 6
            je      move_TDE_forward2
            mov     edi, DWORD [BDEy]
            sub     edi, 3
            cmp     DWORD [TDEy], edi
            je      move_TDE_forward2
            mov     eax, DWORD [NTx]
            cmp     DWORD [TDEx], eax
            je      move_TDE_forward2
                add     DWORD [TDEy], 3
                jmp     end_move2

        move_TDE_forward2:
            mov     eax, DWORD [NTy]
            cmp     DWORD [TDEy], eax
            je      end_move2
            cmp     DWORD [BDEx], 67
            je      end_move2
                sub     DWORD [BDEx], 6
                jmp     end_move2

    move_BDE2:
    mov     eax, DWORD [NTy]
    cmp     DWORD [BDEy], eax
    jge     move_BDE_down2
    cmp     DWORD [BDEy], eax
    jl      move_BDE_up2

        move_BDE_down2:
            cmp     DWORD [BDEy], 9
            je      move_BDE_forward2
                add     DWORD [BDEy], 3
                jmp     end_move2

        move_BDE_up2:
            cmp     DWORD [BDEy], 6
            je      move_BDE_forward2
            mov     edi, DWORD [TDEy]
            add     edi, 3
            cmp     DWORD [BDEy], edi
            je      move_BDE_forward2
            mov     eax, DWORD [NTx]
            cmp     DWORD [BDEx], eax
            je      move_BDE_forward2
                sub     DWORD [BDEy], 3
                jmp     end_move2

        move_BDE_forward2:
            mov     eax, DWORD [NTy]
            cmp     DWORD [BDEy], eax
            je      end_move2
            cmp     DWORD [BDEx], 67
            je      end_move2
                sub     DWORD [BDEx], 6
                jmp     end_move2

    move_LB2:
    mov     eax, DWORD [ypos]
    cmp     DWORD [LBy], eax
    jg      move_LB_up2
    cmp     DWORD [LBy], eax
    jl      move_LB_down2
    jmp     end_move2

        move_LB_up2:
            sub     DWORD [LBy], 3
            jmp     end_move2

        move_LB_down2:
            add     DWORD [LBy], 3
            jmp     end_move2

    move_DB2:
    mov     eax, DWORD [ypos]
    cmp     DWORD [DBy], eax
    jg      move_DB_up2
    cmp     DWORD [DBy], eax
    jl      move_DB_down2
    jmp     end_move2

        move_DB_up2:
            sub     DWORD [DBy], 3
            jmp     end_move2

        move_DB_down2:
            add     DWORD [DBy], 3
            jmp     end_move2

    end_move2:
    mov     esp, ebp
    pop     ebp
    ret                                                                   
